////  Game.m//  NumbersTo1////  Created by Micah Holden on 2/19/10.//  Copyright 2010 __MyCompanyName__. All rights reserved.//#import "Game.h"@implementation Game#pragma mark -#pragma mark Initialization- (void)awakeFromNib{	[NSApp setDelegate:self];	savedLevels = [NSUserDefaults standardUserDefaults];	NSData *data = [savedLevels objectForKey:@"buttons"];	if(data == nil)	{		buttons = [[NSMutableArray alloc]init];		colorsOn = NO;		shuffling = NO;		moves = 0;		[self dimChangeTo:4];		savedLevels = [NSUserDefaults standardUserDefaults];		if([savedLevels stringForKey:@"Four"] == nil) [savedLevels setObject:@"4"  forKey:@"Four"];		if([savedLevels stringForKey:@"Five"] == nil) [savedLevels setObject:@"5" forKey:@"Five"];		if([savedLevels stringForKey:@"Six"] == nil) [savedLevels setObject:@"6" forKey:@"Six"];		if([savedLevels stringForKey:@"Seven"] == nil) [savedLevels setObject:@"7" forKey:@"Seven"];		if([savedLevels stringForKey:@"Eight"] == nil) [savedLevels setObject:@"8" forKey:@"Eight"];		if([savedLevels stringForKey:@"Move"] == nil) [savedLevels setObject:[NSString stringWithFormat:@"Move: 0/%d",[[savedLevels stringForKey:@"Four"]intValue]] forKey:@"Move"];		if([savedLevels stringForKey:@"Level"] == nil) [savedLevels setObject:[NSString stringWithFormat:@"Level: 4.%d",[[savedLevels stringForKey:@"Four"]intValue]] forKey:@"Level"];		else if([[savedLevels stringForKey:@"Four"]isEqualToString:@"25+"])		{			[savedLevels setObject:@"Level: 4.25+" forKey:@"Level"];		}		level = [[savedLevels objectForKey:@"Four"]intValue];		[savedLevels setObject:[NSString stringWithFormat:@"Move: 0/%d",level] forKey:@"Move"];		undoMoves = [[NSUndoManager alloc]init];	}	else	{		NSArray *oldArr = [NSKeyedUnarchiver unarchiveObjectWithData:data];		if(oldArr != nil) buttons = [[NSMutableArray alloc]initWithArray:oldArr];		else buttons = [[NSMutableArray alloc]init];		colorsOn = NO;		shuffling = NO;		moves = [savedLevels integerForKey:@"moves"];		level = [savedLevels integerForKey:@"level"];		undoMoves = [savedLevels objectForKey:@"undoMoves"];		zrow = [savedLevels integerForKey:@"zrow"];		zcol = [savedLevels integerForKey:@"zcol"];		dim = [savedLevels integerForKey:@"dim"];	}}- (void)applicationWillTerminate:(NSNotification*)note{	[savedLevels setInteger:moves forKey:@"moves"];	[savedLevels setInteger:level forKey:@"level"];	[savedLevels setInteger:zrow forKey:@"zrow"];	[savedLevels setInteger:zcol forKey:@"zcol"];	[savedLevels setInteger:dim forKey:@"dim"];	[savedLevels setObject:buttons forKey:@"buttons"];	[savedLevels setObject:undoMoves forKey:@"buttons"];}#pragma mark -#pragma mark Buttons Pressed- (void)buttonsPressed:(MyButton*)sender{	if(!shuffling)	{		if(fabs(zcol-[sender col])>1 && [sender row] == zrow)		{			if([self moveRow:sender])			{				[undoMoves registerUndoWithTarget:self selector:@selector(undoMove:) object:sender];				moves++;				[self checkWin];			}		}		else if(fabs(zrow-[sender row])>1 && [sender col] == zcol)		{			if([self moveCol:sender])			{				[undoMoves registerUndoWithTarget:self selector:@selector(undoMove:) object:sender];				moves++;				[self checkWin];			}		}		[savedLevels setObject:[NSString stringWithFormat:@"Move: %d/%d",moves,level] forKey:@"Move"];	}	else	{		if(fabs(zcol-sender.col)>1 && sender.row == zrow)		{			if([self checkMoveRow:sender]) shuffleCount++;		}		else if(fabs(zrow-sender.row)>1 && sender.col == zcol)		{			if([self checkMoveCol:sender]) shuffleCount++;		}	}	}- (IBAction)shuffle:(id)sender{	shuffling = YES;	while(shuffling)	{		if([self shuffleButtons]) shuffling = NO;	}}- (IBAction)undo:(id)sender{	if([undoMoves canUndo])	{		[undoMoves undo];	}}- (IBAction)color:(id)sender{	colorsOn = !colorsOn;	[self fixColors];	if(colorsOn)	{		for(MyButton* b in buttons)			[b setColored:YES];	}	else 	{		for(MyButton* b in buttons)			[b setColored:NO];	}}- (IBAction)restart:(id)sender{	while([undoMoves canUndo])		[undoMoves undo];}- (IBAction)dimPressed:(id)sender{	[self dimChangeTo:[[sender selectedCell]tag]];}- (IBAction)resetLevels:(id)sender{	[savedLevels setObject:@"4" forKey:@"Four"];	[savedLevels setObject:@"5" forKey:@"Five"];	[savedLevels setObject:@"6" forKey:@"Six"];	[savedLevels setObject:@"7" forKey:@"Seven"];	[savedLevels setObject:@"8" forKey:@"Eight"];	switch(dim)	{		case 4:			[self setLevel:[[savedLevels stringForKey:@"Four"]intValue]];			break;		case 5:			[self setLevel:[[savedLevels stringForKey:@"Five"]intValue]];			break;		case 6:			[self setLevel:[[savedLevels stringForKey:@"Six"]intValue]];			break;		case 7:			[self setLevel:[[savedLevels stringForKey:@"Seven"]intValue]];			break;		case 8:			[self setLevel:[[savedLevels stringForKey:@"Eight"]intValue]];			break;	}}#pragma mark -#pragma mark Update View- (void)dimChangeTo:(int)dimension{	int s=0;	NSFont *f=nil;	dim = dimension;	[buttons removeAllObjects];	[buttonData removeAllObjects];	level = [self getLevels];	switch (dim)	{		case 4:			s = 128;			f = [NSFont fontWithName:@"Lucida Grande" size:120];			break;		case 5:			s = 100;			f = [NSFont fontWithName:@"Lucida Grande" size:96];			break;		case 6:			s = 84;			f = [NSFont fontWithName:@"Lucida Grande" size:72];			break;		case 7:			s = 70;			f = [NSFont fontWithName:@"Lucida Grande" size:64];			break;		case 8:			s = 60;			f = [NSFont fontWithName:@"Lucida Grande" size:48];			break;	}	int i=0;	for(i=0; i<dim*dim-1; i++)	{		//NSRect r = NSMakeRect(X14, Y14, 128, 128);		NSRect r = NSMakeRect((s+8)*(i/dim), 555-(s+8)-(s+8)*(i%dim), s, s);		MyButton *b = [[MyButton alloc]initWithFrame:r];		Button *but = [[Button alloc]init];		[b setInitialRow:(i%dim) Col:(i/dim)];		but.initialRow = (i%dim);		but.initialCol = (i/dim);		but.row = (i%dim);		but.col = (i/dim);		[b setCurrentValue:1];		but.currentValue = 1;		[b setDim:dim color:i/dim];		but.dim = dim;		if(colorsOn) [b setColor];		but.color = (i/dim);		[b setTarget:self];		[b setAction:@selector(buttonsPressed:)];		[b setFont:f];		[b setBezelStyle:NSSmallSquareBezelStyle];		[b setBordered:YES];		[buttons addObject:b];		[buttonData addObject:but];		[b release];		[but release];	}	[view setSubviews:buttons];	if(colorsOn) [self fixColors];	[self setLevel:level];}- (void)fixColors{	NSSize s;	if([colors numberOfColumns]<dim)	{		while([colors numberOfColumns]<dim)			[colors addColumn];	}	else 	{		while([colors numberOfColumns]>dim)			[colors removeColumn:[colors numberOfColumns]-1];	}	switch(dim)	{		case 4:			s = NSMakeSize(128, 17);			break;		case 5:			s = NSMakeSize(100, 17);			[[colors cellAtRow:0 column:4]setBackgroundColor:[NSColor purpleColor]];			break;		case 6:			s = NSMakeSize(84, 17);			[[colors cellAtRow:0 column:4]setBackgroundColor:[NSColor purpleColor]];			[[colors cellAtRow:0 column:5]setBackgroundColor:[NSColor orangeColor]];			break;		case 7:			s = NSMakeSize(70, 17);			[[colors cellAtRow:0 column:4]setBackgroundColor:[NSColor purpleColor]];			[[colors cellAtRow:0 column:5]setBackgroundColor:[NSColor orangeColor]];			[[colors cellAtRow:0 column:6]setBackgroundColor:[NSColor cyanColor]];			break;		case 8:			s = NSMakeSize(60, 17);			[[colors cellAtRow:0 column:4]setBackgroundColor:[NSColor purpleColor]];			[[colors cellAtRow:0 column:5]setBackgroundColor:[NSColor orangeColor]];			[[colors cellAtRow:0 column:6]setBackgroundColor:[NSColor cyanColor]];			[[colors cellAtRow:0 column:7]setBackgroundColor:[NSColor magentaColor]];			break;	}	if(colorsOn)	{		[colors setCellSize:s];		[colors sizeToCells];		[colors setHidden:NO];	}	else [colors setHidden:YES];	[self setButText];}- (void)setButText{	for(MyButton* b in buttons)		[b setButText];}#pragma mark -#pragma mark Level Manipulation- (void)saveLevels{	switch(dim)	{		case 4:			if(level < 25) [savedLevels setObject:[NSString stringWithFormat:@"%d",level] forKey:@"Four"];			else [savedLevels setObject:@"25+" forKey:@"Four"];			[savedLevels setObject:[NSString stringWithFormat:@"Level: 4.%@",[savedLevels objectForKey:@"Four"]] forKey:@"Level"];			break;		case 5:			if(level < 30) [savedLevels setObject:[NSString stringWithFormat:@"%d",level] forKey:@"Five"];			else [savedLevels setObject:@"30+" forKey:@"Five"];			[savedLevels setObject:[NSString stringWithFormat:@"Level: 5.%@",[savedLevels objectForKey:@"Five"]] forKey:@"Level"];			break;		case 6:			if(level < 35) [savedLevels setObject:[NSString stringWithFormat:@"%d",level] forKey:@"Six"];			else [savedLevels setObject:@"35+" forKey:@"Six"];			[savedLevels setObject:[NSString stringWithFormat:@"Level: 6.%@",[savedLevels objectForKey:@"Six"]] forKey:@"Level"];			break;		case 7:			if(level < 50) [savedLevels setObject:[NSString stringWithFormat:@"%d",level] forKey:@"Seven"];			else [savedLevels setObject:@"50+" forKey:@"Seven"];			[savedLevels setObject:[NSString stringWithFormat:@"Level: 7.%@",[savedLevels objectForKey:@"Seven"]] forKey:@"Level"];			break;		case 8:			if(level < 75) [savedLevels setObject:[NSString stringWithFormat:@"%d",level] forKey:@"Eight"];			else [savedLevels setObject:@"75+" forKey:@"Eight"];			[savedLevels setObject:[NSString stringWithFormat:@"Level: 8.%@",[savedLevels objectForKey:@"Eight"]] forKey:@"Level"];			break;	}	[savedLevels setObject:[NSString stringWithFormat:@"Move: 0/%d",level] forKey:@"Move"];}- (int)getLevels{	int x = 0;	switch(dim)	{		case 4:			x = [[savedLevels stringForKey:@"Four"]intValue];			break;		case 5:			x = [[savedLevels stringForKey:@"Five"]intValue];			break;		case 6:			x = [[savedLevels stringForKey:@"Six"]intValue];			break;		case 7:			x = [[savedLevels stringForKey:@"Seven"]intValue];			break;		case 8:			x = [[savedLevels stringForKey:@"Eight"]intValue];			break;	}	return x;}- (void)setLevel:(int)lev{	int x=0;	switch(dim)	{		case 4:			if(lev < 26) level=lev;			else 			{				x=arc4random() % dim;				level = 25+x;			}			break;		case 5:			if(lev < 31) level=lev;			else 			{				x=arc4random() % dim;				level = 30+x;			}			break;		case 6:			if(lev < 36) level=lev;			else 			{				x=arc4random() % dim;				level = 35+x;			}			break;		case 7:			if(lev < 51) level=lev;			else 			{				x=arc4random() % dim;				level = 50+x;			}			break;		case 8:			if(lev < 76) level=lev;			else 			{				x=arc4random() % dim;				level = 75+x;			}			break;	}	[self saveLevels];}- (NSString*)pathForDataFile{	NSFileManager *fileManager = [NSFileManager defaultManager];	NSString* folder = @"~/Library/Application Support/NumbersTo1/";	folder = [folder stringByExpandingTildeInPath];	if([fileManager fileExistsAtPath:folder] == NO)		[fileManager createDirectoryAtPath:folder withIntermediateDirectories:NO attributes:nil error:NULL];	NSString* fileName = @"data.N21";	return [folder stringByAppendingPathComponent:fileName];}- (void)saveDataToDisk{	/*NSMutableData* writeData = [NSMutableData data];	NSKeyedArchiver* archiver = [[NSKeyedArchiver alloc]initForWritingWithMutableData:writeData];	NSString* path = [self pathForDataFile];		[archiver encodeObject:buttonData forKey:@"buttons"];	[archiver encodeInt:moves forKey:@"moves"];	[archiver encodeInt:level forKey:@"level"];	[archiver encodeInt:zrow forKey:@"zrow"];	[archiver encodeInt:zcol forKey:@"zcol"];	[archiver encodeInt:dim forKey:@"dim"];	//[archiver encodeObject:undoMoves forKey:@"undoMoves"];	[archiver finishEncoding];		[writeData writeToFile:path atomically:YES];	[archiver release];*/}- (void)loadDataFromDisk{	/*NSString* path = [self pathForDataFile];	NSMutableData *theData;	NSKeyedUnarchiver *decoder;		theData = [NSData dataWithContentsOfFile:path];	decoder = [[NSKeyedUnarchiver alloc]initForReadingWithData:theData];	buttonData = [decoder decodeObjectForKey:@"buttons"];	moves = [decoder decodeIntForKey:@"moves"];	level = [decoder decodeIntForKey:@"level"];	zrow = [decoder decodeIntForKey:@"zrow"];	zcol = [decoder decodeIntForKey:@"zcol"];	dim = [decoder decodeIntForKey:@"dim"];	for(Button* bd in buttonData)	{		MyButton* b = [[MyButton alloc]init];		[b setInitialRow:bd.initialRow Col:bd.initialCol];		[b setRow:bd.row Col:bd.col];		[b setCurrentValue:bd.currentValue];		[b setDim:dim color:bd.color];		[b setPrevPositions:bd.prevPositions];		[b setPrevValues:bd.prevValues];		[b setPrevRows:bd.prevRows];		[b setPrevCols:bd.prevCols];		[buttons addObject:b];		[b release];	}	//undoMoves = [decoder decodeObjectForKey:@"undoMoves"];	[decoder finishDecoding];	[decoder release];*/}#pragma mark -#pragma mark Board Setup- (BOOL)shuffleButtons{	int r,c,count;	moves = 0;	count = 0;	shuffleCount = 0;	[self resetButtons];	zrow = dim-1;	zcol = dim-1;	[undoMoves removeAllActions];	while(shuffleCount < level)	{		r=arc4random()%dim;		c=arc4random()%dim;		for(MyButton* b in buttons)		{			if([b isInRow:r Col:c])			{				[self buttonsPressed:b];				break;			}		}		count++;		if(count > 500) return NO;	}	return YES;}- (void)resetButtons{	for(MyButton* b in buttons)	{		b.currentValue = 1;		[b revertToInitialFrame];	}}#pragma mark -#pragma mark Moving Buttons- (BOOL)checkMoveRow:(MyButton *)button{	int x=0;	if(fabs(button.col-zcol)<2)return NO;	if(zcol > button.col)	{		for(MyButton* b in buttons)		{			if(b.row == button.row && b.col >= button.col && b.col < zcol)				x+=b.currentValue;		}	}	else	{		for(MyButton* b in buttons)		{			if(b.row == button.row && b.col <= button.col && b.col > zcol)				x+=b.currentValue;		}	}	if(x>6) return NO;	[button setCurrentValue:x];	int temp1 = zrow;	int temp2 = zcol;	zrow = button.row;	zcol = button.col;	[view addSubview:button positioned:NSWindowAbove relativeTo:nil];	[button setRow:temp1 Col:temp2];	return YES;}- (BOOL)checkMoveCol:(MyButton *)button{	int x=0;	if(fabs(button.row-zrow)<2)return NO;	if(zrow > button.row)	{		for(MyButton* b in buttons)		{			if(b.col == button.col && b.row >= button.row && b.row < zrow)				x+=b.currentValue;		}	}	else	{		for(MyButton* b in buttons)		{			if(b.col == button.col && b.row <= button.row && b.row > zrow)				x+=b.currentValue;		}	}	if(x>6) return NO;	[button setCurrentValue:x];	int temp1 = zrow;	int temp2 = zcol;	zrow = button.row;	zcol = button.col;	[view addSubview:button positioned:NSWindowAbove relativeTo:nil];	[button setRow:temp1 Col:temp2];	return YES;}- (BOOL)moveRow:(MyButton *)button{	int x;	if(fabs(button.col - zcol)<2) return NO;	x = button.currentValue;	if(zcol > button.col)	{		for(MyButton* b in buttons)		{			if(b != button && b.row == button.row && b.col>button.col && b.col < zcol)				x-=b.currentValue;		}	}	else	{		for(MyButton* b in buttons)		{			if(b != button && b.row == button.row && b.col<button.col && b.col > zcol)				x-=b.currentValue;		}	}	if(x<1) return NO;	[button addPosition];	[button setCurrentValue:x];	int temp1 = zrow;	int temp2 = zcol;	zrow = button.row;	zcol = button.col;	[view addSubview:button positioned:NSWindowAbove relativeTo:nil];	[button setRow:temp1 Col:temp2];	return YES;}- (BOOL)moveCol:(MyButton *)button{	int x;	if(fabs(button.row - zrow)<2) return NO;	x = button.currentValue;	if(zrow > button.row)	{		for(MyButton* b in buttons)		{			if(b != button && b.col == button.col && b.row>button.row && b.row < zrow)				x-=b.currentValue;		}	}	else	{		for(MyButton* b in buttons)		{			if(b != button && b.col == button.col && b.row<button.row && b.row > zrow)				x-=b.currentValue;		}	}	if(x<1) return NO;	[button addPosition];	[button setCurrentValue:x];	int temp1 = zrow;	int temp2 = zcol;	zrow = button.row;	zcol = button.col;	[view addSubview:button positioned:NSWindowAbove relativeTo:nil];	[button setRow:temp1 Col:temp2];	return YES;}#pragma mark -#pragma mark Undo Check for Winner- (void)undoMove:(MyButton *)button{	zrow = button.row;	zcol = button.col;	[button undo];	moves--;	[savedLevels setObject:[NSString stringWithFormat:@"Move: %d/%d",moves,level] forKey:@"Move"];}- (BOOL)checkWin{	for(MyButton* b in buttons)	{		if(b.currentValue != 1) return NO;		if([b isInRow:dim-1 Col:dim-1]) return NO;	}	[self setLevel:level+1];	[undoMoves removeAllActions];	shuffling = YES;	while(shuffling)	{		if([self shuffleButtons])shuffling = NO;	}	return YES;}@synthesize colors;@synthesize dimMat;@synthesize view;@synthesize undoMoves;@synthesize savedLevels;@end